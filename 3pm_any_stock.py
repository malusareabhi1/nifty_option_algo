# base_zone_strategy_any_stock.py
# Streamlit app: Base Zone strategy adaptable to any stock/index symbol
# Author: Generated by assistant for Prakash

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import datetime
from datetime import datetime, timedelta
import plotly.graph_objects as go


# Optional libraries that may be used for option chain or TA
try:
    import ta
except Exception:
    ta = None

# Optional NSE scraping tools (only used for NIFTY/BANKNIFTY option chain)
try:
    from nsepython import nse_optionchain_scrapper
    from nsepython import *
except Exception:
    nse_optionchain_scrapper = None

# ------------------------- Helper & Core Functions -------------------------

st.set_page_config(layout="wide")
st.title("Base Zone Strategy - Multi-Stock/Index Backtest")

# ----------------- Plotting multi-day candles with previous day 3PM lines -----------------

def plot_nifty_multiday(df, trading_days):
    fig = go.Figure()
    for i in range(1, len(trading_days)):
        day0 = trading_days[i-1]
        day1 = trading_days[i]
        df_day1 = df[df['Datetime'].dt.date == day1]
        fig.add_trace(go.Candlestick(
            x=df_day1['Datetime'],
            open=df_day1['Open'],
            high=df_day1['High'],
            low=df_day1['Low'],
            close=df_day1['Close'],
            name=f"{day1}"
        ))

        candle_3pm = df[df['Datetime'].dt.date == day0]
        candle_3pm = candle_3pm[(candle_3pm['Datetime'].dt.hour == 15) & (candle_3pm['Datetime'].dt.minute == 0)]
        if not candle_3pm.empty:
            open_3pm = candle_3pm.iloc[0]['Open']
            close_3pm = candle_3pm.iloc[0]['Close']
            day1_3pm_candle = df_day1[(df_day1['Datetime'].dt.hour == 15) & (df_day1['Datetime'].dt.minute == 0)]
            if not day1_3pm_candle.empty:
                x_end = day1_3pm_candle['Datetime'].iloc[0]
                x_start = df_day1['Datetime'].min()
                fig.add_shape(type="line", x0=x_start, x1=x_end, y0=open_3pm, y1=open_3pm,
                              line=dict(color="blue", width=1, dash="dot"))
                fig.add_shape(type="line", x0=x_start, x1=x_end, y0=close_3pm, y1=close_3pm,
                              line=dict(color="red", width=1, dash="dot"))

    fig.update_layout(title="15-min Candles with Previous Day 3PM Open/Close Lines",
                      xaxis_rangeslider_visible=False,
                      xaxis=dict(rangebreaks=[dict(bounds=["sat","mon"]), dict(bounds=[15.5,9.25], pattern="hour")]))
    return fig

# ----------------- Display helpers -----------------

def display_3pm_candle_info(df, day):
    candle = df[(df['Datetime'].dt.date == day) & (df['Datetime'].dt.hour == 15) & (df['Datetime'].dt.minute == 0)]
    if candle.empty:
        st.warning(f"No 3:00 PM candle found for {day}")
        return None, None
    open_price = candle.iloc[0]['Open']
    close_price = candle.iloc[0]['Close']
    return open_price, close_price


def display_current_trend(df):
    if df.empty:
        st.warning("No candle data available.")
        return
    current_candle = df.iloc[-1]
    open_price = current_candle['Open']
    close_price = current_candle['Close']
    if close_price > open_price:
        st.markdown("<span style='color:green; font-weight:bold;'>Trend: Bullish üî•</span>", unsafe_allow_html=True)
    elif close_price < open_price:
        st.markdown("<span style='color:red; font-weight:bold;'>Trend: Bearish ‚ùÑÔ∏è</span>", unsafe_allow_html=True)
    else:
        st.markdown("<span style='color:gray; font-weight:bold;'>Trend: Doji ‚ö™</span>", unsafe_allow_html=True)

# ----------------- Trading signal logic (adapted to generic "Open/High/Low/Close") -----------------

def get_nearest_weekly_expiry(today):
    # Simple placeholder: next Friday
    today = pd.to_datetime(today).normalize()
    # find next Friday
    days_ahead = (4 - today.weekday()) % 7
    if days_ahead == 0:
        days_ahead = 7
    return today + pd.Timedelta(days=days_ahead)


def get_nearest_itm_option(spot_price, option_type="CALL", strike_step=50):
    spot_price = round(spot_price / strike_step) * strike_step
    if option_type.upper() == "CALL":
        return int(spot_price - strike_step)
    elif option_type.upper() == "PUT":
        return int(spot_price + strike_step)
    else:
        raise ValueError("option_type must be CALL or PUT")


# Option chain finder - works only when nsepython is available and symbol is index
def option_chain_finder(option_chain_df, spot_price, option_type, lots=10, lot_size=75):
    # If option_chain_df is a pandas DataFrame similar to earlier structure
    df = option_chain_df.copy()
    # normalize expiry
    if 'expiryDate' in df.columns:
        df['expiryDate'] = pd.to_datetime(df['expiryDate'])
    today = pd.Timestamp.today().normalize()
    expiries = df.loc[df['expiryDate'] >= today, 'expiryDate'].unique()
    nearest_expiry = min(expiries) if len(expiries) else df['expiryDate'].iloc[0]
    df_exp = df[(df['expiryDate'] == nearest_expiry) & (df['optionType'].isin(['CE','PE']))]
    if df_exp.empty:
        raise ValueError("No options available for selected expiry")
    if option_type.upper() in ['CE','CALL']:
        itm = df_exp[(df_exp['optionType']=='CE') & (df_exp['strikePrice'] <= spot_price)]
        if itm.empty:
            nearest_strike = df_exp[df_exp['optionType']=='CE']['strikePrice'].min()
        else:
            nearest_strike = itm['strikePrice'].max()
        opt_row = df_exp[(df_exp['strikePrice']==nearest_strike) & (df_exp['optionType']=='CE')].iloc[0]
    else:
        itm = df_exp[(df_exp['optionType']=='PE') & (df_exp['strikePrice'] >= spot_price)]
        if itm.empty:
            nearest_strike = df_exp[df_exp['optionType']=='PE']['strikePrice'].max()
        else:
            nearest_strike = itm['strikePrice'].min()
        opt_row = df_exp[(df_exp['strikePrice']==nearest_strike) & (df_exp['optionType']=='PE')].iloc[0]
    total_qty = lots * lot_size
    return {'strikePrice': nearest_strike, 'expiryDate': nearest_expiry, 'optionType': opt_row['optionType'], 'total_quantity': total_qty, 'option_data': opt_row}


# ----------------- Signal engines (simplified & unified) -----------------

def trading_signal_all_conditions_generic(df, quantity=10*75, return_all_signals=False):
    # This function uses column names Open/High/Low/Close and is symbol agnostic
    df = df.copy()
    df['Date'] = df['Datetime'].dt.date
    unique_days = sorted(df['Date'].unique())
    if len(unique_days) < 2:
        return None
    day0 = unique_days[-2]
    day1 = unique_days[-1]
    candle_3pm = df[(df['Date']==day0) & (df['Datetime'].dt.hour==15) & (df['Datetime'].dt.minute==0)]
    if candle_3pm.empty:
        return None
    base_open = candle_3pm.iloc[0]['Open']
    base_close = candle_3pm.iloc[0]['Close']
    base_low = min(base_open, base_close)
    base_high = max(base_open, base_close)

    candle_915 = df[(df['Date']==day1) & (df['Datetime'].dt.hour==9) & (df['Datetime'].dt.minute==15)]
    if candle_915.empty:
        return None
    H1 = candle_915.iloc[0]['High']
    L1 = candle_915.iloc[0]['Low']
    C1 = candle_915.iloc[0]['Close']
    entry_time = candle_915.iloc[0]['Datetime']
    spot_price = df['Close'].iloc[-1]
    expiry = get_nearest_weekly_expiry(pd.to_datetime(day1))

    signals = []
    # Condition 1
    if (L1 < base_high and H1 > base_low) and (C1 > base_high):
        signals.append({'condition':1,'option_type':'CALL','buy_price':H1,'quantity':quantity,'expiry':expiry,'entry_time':entry_time,'message':'Cond1: Breakout'})
        if not return_all_signals: return signals[0]
    # Condition 2
    if C1 < base_low:
        day1_after = df[(df['Date']==day1) & (df['Datetime']>entry_time)].sort_values('Datetime')
        for _, nxt in day1_after.iterrows():
            if nxt['Low'] <= L1:
                signals.append({'condition':2,'option_type':'PUT','buy_price':L1,'quantity':quantity,'expiry':expiry,'entry_time':nxt['Datetime'],'message':'Cond2: Gap down'})
                if not return_all_signals: return signals[-1]
            if nxt['Close'] > base_high:
                signals.append({'condition':2.7,'option_type':'CALL','buy_price':nxt['High'],'quantity':quantity,'expiry':expiry,'entry_time':nxt['Datetime'],'message':'Cond2.7 Flip'})
                if not return_all_signals: return signals[-1]
    # Condition 3
    if C1 > base_high:
        day1_after = df[(df['Date']==day1) & (df['Datetime']>entry_time)].sort_values('Datetime')
        for _, nxt in day1_after.iterrows():
            if nxt['High'] >= H1:
                signals.append({'condition':3,'option_type':'CALL','buy_price':H1,'quantity':quantity,'expiry':expiry,'entry_time':nxt['Datetime'],'message':'Cond3: Gap up'})
                if not return_all_signals: return signals[-1]
            if nxt['Close'] < base_low:
                signals.append({'condition':3.7,'option_type':'PUT','buy_price':nxt['Low'],'quantity':quantity,'expiry':expiry,'entry_time':nxt['Datetime'],'message':'Cond3.7 Flip'})
                if not return_all_signals: return signals[-1]
    # Condition 4
    if (L1 < base_high and H1 > base_low) and (C1 < base_low):
        signals.append({'condition':4,'option_type':'PUT','buy_price':L1,'quantity':quantity,'expiry':expiry,'entry_time':entry_time,'message':'Cond4: Breakdown'})
        if not return_all_signals: return signals[-1]
    return signals if signals else None


# ----------------- Trade log and plotting utilities -----------------

def generate_trade_log_from_option(result, trade_signal):
    if result is None or trade_signal is None:
        return None
    option = result['option_data']
    qty = result['total_quantity']
    condition = trade_signal.get('condition')
    entry_time = trade_signal.get('entry_time')
    message = trade_signal.get('message')
    buy_price = option.get('lastPrice', trade_signal.get('buy_price'))
    expiry = option.get('expiryDate', trade_signal.get('expiry'))
    option_type = option.get('optionType', trade_signal.get('option_type'))
    stoploss = buy_price * 0.9 if buy_price is not None else None
    take_profit = buy_price * 1.10 if buy_price is not None else None
    partial_qty = qty // 2
    time_exit = entry_time + timedelta(minutes=16) if hasattr(entry_time,'tzinfo') or isinstance(entry_time, pd.Timestamp) else entry_time + timedelta(minutes=16)
    trade_log = {
        "Condition": condition,
        "Option Type": option_type,
        "Strike Price": option.get('strikePrice'),
        "Buy Premium": buy_price,
        "Stoploss (Trailing 10%)": stoploss,
        "Take Profit (10% rise)": take_profit,
        "Quantity": qty,
        "Partial Profit Booking Qty (50%)": partial_qty,
        "Expiry Date": expiry.strftime('%Y-%m-%d') if hasattr(expiry,'strftime') else expiry,
        "Entry Time": entry_time.strftime('%Y-%m-%d %H:%M:%S') if hasattr(entry_time,'strftime') else entry_time,
        "Time Exit (16 mins after entry)": time_exit.strftime('%Y-%m-%d %H:%M:%S') if hasattr(time_exit,'strftime') else time_exit,
        "Trade Message": message
    }
    trade_log_df = pd.DataFrame([trade_log])
    return trade_log_df


def calculate_trade_cost(buy_price, sell_price, quantity, option_type="CE", brokerage_type="fixed"):
    turnover = (buy_price + sell_price) * quantity
    if brokerage_type == "fixed":
        brokerage = 20
    else:
        brokerage = turnover * 0.0003
    exchange_charges = turnover * 0.0000325
    gst = 0.18 * brokerage
    sebi_charges = turnover * 0.000001
    stamp_duty = turnover * 0.00003
    total_charges = brokerage + exchange_charges + gst + sebi_charges + stamp_duty
    return total_charges


def compute_trade_pnl_with_costs(signal_log_df, df):
    trade_results = []
    capital = 0
    for _, row in signal_log_df.iterrows():
        day = row['Date']
        entry_time = row['Entry Time']
        exit_time = row['Time Exit (16 mins after entry)']
        buy_premium = row['Buy Premium']
        qty = int(row['Quantity'])
        stoploss = row.get('Stoploss (Trailing 10%)')
        take_profit = row.get('Take Profit (10% rise)')
        option_type = row.get('Option Selected', 'CE')
        capital_needed = buy_premium * qty if buy_premium is not None else 0
        day_df = df[df['Datetime'].dt.date == day]
        day_after_entry = day_df[day_df['Datetime'] >= entry_time].sort_values('Datetime')
        sell_price = None
        exit_reason = "Time Exit"
        for _, candle in day_after_entry.iterrows():
            price = candle['Close']
            if take_profit and price >= take_profit:
                sell_price = take_profit
                exit_reason = "Take Profit"
                exit_time = candle['Datetime']
                break
            elif stoploss and price <= stoploss:
                sell_price = stoploss
                exit_reason = "Stoploss"
                exit_time = candle['Datetime']
                break
        if sell_price is None:
            if not day_after_entry.empty:
                sell_price = day_after_entry['Close'].iloc[-1]
            else:
                sell_price = buy_premium
        raw_pnl = (sell_price - buy_premium) * qty if option_type.upper() == "CE" else (buy_premium - sell_price) * qty
        total_charges = calculate_trade_cost(buy_premium, sell_price, qty, option_type)
        net_pnl = raw_pnl - total_charges
        capital += net_pnl
        trade_results.append({**row.to_dict(), "Sell Price": sell_price, "Exit Reason": exit_reason, "Actual Exit Time": exit_time, "Raw PnL": raw_pnl, "Total Charges": total_charges, "Net PnL": net_pnl, "Capital Needed": capital_needed, "Capital After Trade": capital})
    return pd.DataFrame(trade_results)

# ----------------- PnL & Performance -----------------

def compute_trade_pnl(signal_log_df, df):
    trade_results = []
    for _, row in signal_log_df.iterrows():
        day = row['Date']
        entry_time = row['Entry Time']
        exit_time = row['Time Exit (16 mins after entry)']
        buy_premium = row['Buy Premium']
        qty = int(row['Quantity'])
        stoploss = row.get('Stoploss (Trailing 10%)')
        take_profit = row.get('Take Profit (10% rise)')
        option_type = row.get('Option Selected', 'CE')
        day_df = df[df['Datetime'].dt.date == day]
        day_after_entry = day_df[(day_df['Datetime'] >= entry_time) & (day_df['Datetime'] <= exit_time)].sort_values('Datetime')
        sell_price = None
        actual_exit_time = exit_time
        exit_reason = "Time Exit"
        for _, candle in day_after_entry.iterrows():
            price = candle['Close']
            if take_profit and ((option_type.upper() == "CE" and price >= take_profit) or (option_type.upper() == "PE" and price <= take_profit)):
                sell_price = take_profit
                exit_reason = "Take Profit"
                actual_exit_time = candle['Datetime']
                break
            elif stoploss and ((option_type.upper() == "CE" and price <= stoploss) or (option_type.upper() == "PE" and price >= stoploss)):
                sell_price = stoploss
                exit_reason = "Stoploss"
                actual_exit_time = candle['Datetime']
                break
        if sell_price is None:
            sell_price = day_after_entry['Close'].iloc[-1] if not day_after_entry.empty else buy_premium
        pnl = (sell_price - buy_premium) * qty if option_type.upper() == "CE" else (buy_premium - sell_price) * qty
        trade_results.append({**row.to_dict(), "Sell Price": sell_price, "Exit Reason": exit_reason, "Actual Exit Time": actual_exit_time, "PnL": pnl})
    return pd.DataFrame(trade_results)


def compute_performance(signal_df, brokerage_per_trade=20, gst_rate=0.18, stamp_duty_rate=0.00015, starting_capital=0):
    total_trades = len(signal_df)
    winning_trades = signal_df[signal_df['PnL'] > 0]
    losing_trades = signal_df[signal_df['PnL'] <= 0]
    total_pnl = signal_df['PnL'].sum()
    avg_pnl = signal_df['PnL'].mean() if total_trades>0 else 0
    max_pnl = signal_df['PnL'].max() if total_trades>0 else 0
    min_pnl = signal_df['PnL'].min() if total_trades>0 else 0
    win_pct = len(winning_trades)/total_trades*100 if total_trades>0 else 0
    loss_pct = len(losing_trades)/total_trades*100 if total_trades>0 else 0
    pnl_per_day = signal_df.groupby('Date').agg({'PnL':'sum','Quantity':'sum'}).reset_index()
    cost_per_trade_list=[]
    net_pnl_list=[]
    capital_needed_list=[]
    capital_after_list=[]
    current_capital = starting_capital
    for idx,row in pnl_per_day.iterrows():
        day_trades = signal_df[signal_df['Date']==row['Date']]
        day_expense=0
        day_capital_needed=0
        for _,trade in day_trades.iterrows():
            turnover = trade['Buy Premium']*trade['Quantity']*2
            brokerage = brokerage_per_trade
            gst = brokerage*gst_rate
            stamp_duty = turnover*stamp_duty_rate
            total_cost = brokerage+gst+stamp_duty
            day_expense+=total_cost
            trade_capital = trade['Buy Premium']*trade['Quantity']
            day_capital_needed+=trade_capital
        current_capital += row['PnL'] - day_expense
        cost_per_trade_list.append(round(day_expense,2))
        net_pnl_list.append(round(row['PnL']-day_expense,2))
        capital_needed_list.append(round(day_capital_needed,2))
        capital_after_list.append(round(current_capital,2))
    pnl_per_day['Total PnL']=pnl_per_day['PnL'].round(2)
    pnl_per_day['Net Expense']=cost_per_trade_list
    pnl_per_day['Net PnL']=net_pnl_list
    pnl_per_day['Capital Needed']=capital_needed_list
    pnl_per_day['Capital After']=capital_after_list
    pnl_per_day = pnl_per_day[['Date','Total PnL','Net Expense','Net PnL','Capital Needed','Capital After']]
    total_expense = sum(cost_per_trade_list)
    summary = {"Total Trades":total_trades,"Winning Trades":len(winning_trades),"Losing Trades":len(losing_trades),"Win %":round(win_pct,2),"Loss %":round(loss_pct,2),"Total PnL":round(total_pnl,2),"Average PnL":round(avg_pnl,2),"Max PnL":round(max_pnl,2),"Min PnL":round(min_pnl,2),"Total Expense":round(total_expense,2),"Net PnL (After Expenses)":round(sum(net_pnl_list),2),"Final Capital":round(current_capital,2)}
    summary_df = pd.DataFrame([summary])
    return summary_df, pnl_per_day

# ----------------- Execution: Streamlit UI & main loop -----------------

# UI inputs
symbol = st.text_input("Enter Yahoo symbol (e.g., RELIANCE.NS, SBIN.NS, ^NSEI for Nifty)", "^NSEI")
mode = st.selectbox("Mode", ["Auto (Index+Equity)", "Equity Only (no options)"])

start_date = st.date_input("Select Start Date", value=datetime.today().date() - timedelta(days=15))
end_date = st.date_input("Select End Date", value=datetime.today().date())

if start_date >= end_date:
    st.warning("End date must be after start date")
    st.stop()

st.write(f"Selected symbol: {symbol}")

# Download data
download_start = start_date - timedelta(days=1)
df = yf.download(symbol, start=download_start, end=end_date + timedelta(days=1), interval="15m")
if df.empty:
    st.warning("No data for selected range/symbol")
    st.stop()

# Normalize columns to Open/High/Low/Close names
if isinstance(df.columns, pd.MultiIndex):
    df.columns = ['_'.join(col).strip() for col in df.columns.values]

# reset index to Datetime
if 'Datetime' not in df.columns:
    df = df.reset_index()
    df.rename(columns={'index': 'Datetime', 'Adj Close': 'Adj_Close'}, inplace=True)

# If columns include symbol suffixes like 'Open_^NSEI' convert to generic names
col_map = {}
for c in df.columns:
    lower = c.lower()
    if 'open' in lower and 'open' not in col_map:
        col_map[c] = 'Open'
    if 'high' in lower and 'high' not in col_map:
        col_map[c] = 'High'
    if 'low' in lower and 'low' not in col_map:
        col_map[c] = 'Low'
    if 'close' in lower and 'close' not in col_map:
        col_map[c] = 'Close'

# apply mapping
df = df.rename(columns=col_map)

# timezone convert
if df['Datetime'].dt.tz is None:
    try:
        df['Datetime'] = df['Datetime'].dt.tz_localize('UTC').dt.tz_convert('Asia/Kolkata')
    except Exception:
        df['Datetime'] = pd.to_datetime(df['Datetime'])
else:
    df['Datetime'] = df['Datetime'].dt.tz_convert('Asia/Kolkata')

# filter trading hours
try:
    df = df[(df['Datetime'].dt.time >= datetime.strptime("09:15","%H:%M").time()) & (df['Datetime'].dt.time <= datetime.strptime("15:30","%H:%M").time())]
except Exception:
    pass

unique_days = sorted(df['Datetime'].dt.date.unique())
unique_days = [d for d in unique_days if d >= start_date and d <= end_date]
if len(unique_days) < 2:
    st.warning("Not enough trading days in the selected range")
    st.stop()

# Plot multi-day candles
trading_days = sorted([d for d in df['Datetime'].dt.date.unique() if start_date <= d <= end_date])
fig = plot_nifty_multiday(df, trading_days)
st.plotly_chart(fig, use_container_width=True)

# MAIN SIGNAL LOOP
signal_log_list = []
combined_trade_log = []
for i in range(1, len(unique_days)):
    day0 = unique_days[i-1]
    day1 = unique_days[i]
    day_df = df[df['Datetime'].dt.date.isin([day0, day1])]
    signal = trading_signal_all_conditions_generic(day_df)
    # For index symbols we can try improved logic if available
    if signal:
        # show signal
        # get option chain only for indices
        if any(x in symbol.upper() for x in ['NIFTY','^NSEI','BANKNIFTY','BANKNIFTY'] ) and nse_optionchain_scrapper is not None:
            # fetch option chain
            try:
                raw_chain = nse_optionchain_scrapper('NIFTY')
                result_chain = []
                # if function returned dict-like, try to transform
                if isinstance(raw_chain, dict) and 'records' in raw_chain:
                    # reuse earlier parser to flat records
                    recs = []
                    for item in raw_chain['records']['data']:
                        strike = item.get('strikePrice')
                        expiry_dates = raw_chain['records'].get('expiryDates', [])
                        if 'CE' in item:
                            ce = item['CE']
                            ce['strikePrice'] = strike
                            ce['expiryDate'] = ce.get('expiryDate', expiry_dates[0] if expiry_dates else None)
                            ce['optionType'] = 'CE'
                            recs.append(ce)
                        if 'PE' in item:
                            pe = item['PE']
                            pe['strikePrice'] = strike
                            pe['expiryDate'] = pe.get('expiryDate', expiry_dates[0] if expiry_dates else None)
                            pe['optionType'] = 'PE'
                            recs.append(pe)
                    result_chain = pd.DataFrame(recs)
                else:
                    result_chain = pd.DataFrame(raw_chain)
                spot_price = signal.get('spot_price', df['Close'].iloc[-1])
                ot = 'CE' if signal['option_type'].upper()=='CALL' else 'PE'
                result = option_chain_finder(result_chain, spot_price, option_type=ot, lots=10, lot_size=75)
                option_data = result['option_data']
                strike_price = option_data.get('strikePrice')
                buy_premium = option_data.get('lastPrice')
                identifier = option_data.get('identifier', None)
            except Exception as e:
                st.warning(f"Option chain fetch error: {e}")
                result = None
                buy_premium = None
                identifier = None
                strike_price = None
        else:
            # equity-only: simulate selection using nearest ITM strike logic
            spot_price = signal.get('spot_price', df['Close'].iloc[-1])
            ot = 'CE' if signal['option_type'].upper()=='CALL' else 'PE'
            strike_price = get_nearest_itm_option(spot_price, 'CALL' if ot=='CE' else 'PUT')
            buy_premium = None
            identifier = None
            result = None

        sig_log = {
            "Date": day1,
            "Symbol": symbol,
            "Condition Type": signal.get('condition'),
            "Entry Time": signal.get('entry_time'),
            "Spot Price": spot_price,
            "Option Selected": ot,
            "Identifier": identifier,
            "Strike Price": strike_price,
            "Buy Premium": buy_premium,
            "Stoploss (Trailing 10%)": buy_premium * 0.9 if buy_premium else None,
            "Take Profit (10% rise)": buy_premium * 1.1 if buy_premium else None,
            "Quantity": signal.get('quantity'),
            "Partial Profit Booking Qty (50%)": signal.get('quantity')/2 if signal.get('quantity') else None,
            "Expiry Date": signal.get('expiry'),
            "Time Exit (16 mins after entry)": signal.get('entry_time') + pd.Timedelta(minutes=16) if signal.get('entry_time') else None
        }
        signal_log_list.append(sig_log)
        trade_log_df = generate_trade_log_from_option(result, signal)
        if trade_log_df is not None:
            combined_trade_log.append(trade_log_df)

# Display signals and logs
if signal_log_list:
    signal_log_df = pd.DataFrame(signal_log_list)
    st.write("### Signal Log")
    st.dataframe(signal_log_df)
    csv = signal_log_df.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Signal Log CSV", data=csv, file_name="signal_log.csv", mime="text/csv")
else:
    st.write("No trade signals detected for the selected period.")

if combined_trade_log:
    all_trades = pd.concat(combined_trade_log, ignore_index=True)
    st.write("### Combined Trade Log for Selected Period")
    st.dataframe(all_trades)
    csv = all_trades.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Trade Log CSV", data=csv, file_name="multi_day_trade_log.csv", mime="text/csv")

if signal_log_list:
    signal_log_df_with_pnl = compute_trade_pnl(signal_log_df, df)
    st.write("### Signal Log with PnL & Exit Reason")
    st.dataframe(signal_log_df_with_pnl)
    csv = signal_log_df_with_pnl.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Signal Log with PnL CSV", data=csv, file_name="signal_log_pnl.csv", mime="text/csv")

if signal_log_list:
    signal_log_df_with_costs = compute_trade_pnl_with_costs(signal_log_df, df)
    st.write("### Signal Log with PnL, Costs & Capital")
    st.dataframe(signal_log_df_with_costs)
    csv = signal_log_df_with_costs.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Trade Log with Costs CSV", data=csv, file_name="trade_log_with_costs.csv", mime="text/csv")

if signal_log_list:
    signal_log_df_with_pnl = compute_trade_pnl(signal_log_df, df)
    perf_summary_df, pnl_per_day = compute_performance(signal_log_df_with_pnl)
    st.write("### PnL Per Day")
    st.table(pnl_per_day)
    st.write("### Performance Summary")
    st.table(perf_summary_df)
    csv_perf = perf_summary_df.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Performance Summary CSV", data=csv_perf, file_name="performance_summary.csv", mime="text/csv")
    csv_daily = pnl_per_day.to_csv(index=False).encode('utf-8')
    st.download_button(label="Download Daily PnL CSV", data=csv_daily, file_name="pnl_per_day.csv", mime="text/csv")

# Optional: functions for fetching option history or realtime premiums (left as-is, use with care)

def get_option_data(symbol, strike, expiry, option_type, start_date, end_date, interval='15minute'):
    try:
        from nsepy import get_history
    except Exception:
        return None
    opt = get_history(symbol=symbol, start=start_date, end=end_date, index=False, option_type=option_type.upper()[0], strike_price=strike, expiry_date=expiry)
    if opt is None or opt.empty:
        return None
    df_opt = opt[['Open','High','Low','Close']].copy()
    df_opt.index.name = 'Datetime'
    df_opt = df_opt.resample('15T').agg({'Open':'first','High':'max','Low':'min','Close':'last'}).dropna().reset_index()
    return df_opt


def get_option_data_realtime(strike, expiry, option_type):
    if nse_optionchain_scrapper is None:
        return None
    data = nse_optionchain_scrapper("NIFTY")
    # Transform to DataFrame if possible
    return None


def track_trade_exit(signal, option_prices_df):
    sl = signal.get('sl_init', None)
    target1 = signal.get('target1', None)
    highest = signal.get('trigger_level', 0)
    entry_time = signal.get('entry_time')
    time_exit_limit = entry_time + pd.Timedelta(minutes=16) if entry_time is not None else None
    exit_price = None
    exit_reason = None
    exit_time = None
    for _, row in option_prices_df.iterrows():
        price_high = row['High']
        price_low = row['Low']
        t = row['Datetime']
        if sl is not None and price_low <= sl:
            exit_price = sl
            exit_reason = 'SL Hit'
            exit_time = t
            break
        if target1 is not None and price_high >= target1:
            highest = max(highest, price_high)
            sl = max(sl, 0.9 * highest) if sl is not None else 0.9 * highest
            exit_price = target1
            exit_reason = 'Target1 Hit (Partial)'
            exit_time = t
        highest = max(highest, price_high)
        new_sl = 0.9 * highest
        if sl is None or new_sl > sl:
            sl = new_sl
        if price_low <= sl and t > entry_time:
            exit_price = sl
            exit_reason = 'Trailing SL'
            exit_time = t
            break
        if time_exit_limit and t >= time_exit_limit:
            exit_price = row['Close']
            exit_reason = 'Time Exit'
            exit_time = t
            break
    if exit_price is None:
        exit_price = option_prices_df.iloc[-1]['Close'] if not option_prices_df.empty else None
        exit_reason = 'Open Trade'
        exit_time = option_prices_df.iloc[-1]['Datetime'] if not option_prices_df.empty else None
    signal.update({'exit_price': exit_price, 'exit_reason': exit_reason, 'exit_time': exit_time, 'PnL': round((exit_price - signal.get('trigger_level')) * signal.get('quantity',0),2) if signal.get('option_type')=='CALL' else round((signal.get('trigger_level')-exit_price)*signal.get('quantity',0),2)})
    return signal

# End of file
